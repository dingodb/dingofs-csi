package config

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"

	"github.com/jackblack369/dingofs-csi/pkg/k8sclient"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/klog/v2"
)

type DfsSetting struct {
	HashVal string `json:"-"`

	FSID           string   // fsid of DingoFS
	Name           string   `json:"name"`
	MdsAddr        string   `json:"mdsaddr"`
	Source         string   `json:"source"`
	Storage        string   `json:"storage"`
	FormatOptions  string   `json:"format-options"`
	CacheDirs      []string // hostPath using by mount pod
	ClientConfPath string   `json:"-"`

	CachePVCs          []CachePVC           // PVC using by mount pod
	CacheEmptyDir      *CacheEmptyDir       // EmptyDir using by mount pod
	CacheInlineVolumes []*CacheInlineVolume // InlineVolume using by mount pod

	// mount
	VolumeId   string   // volumeHandle of PV
	UniqueId   string   // mount pod name is generated by uniqueId
	MountPath  string   // mountPath of mount pod or process mount
	TargetPath string   // which bind to container path
	Options    []string // mount options
	SubPath    string   // subPath which is to be created or deleted
	SecretName string   // secret with JuiceFS volume credentials

	Attr *PodAttr

	// put in secret
	SecretKey     string            `json:"secret-key,omitempty"`
	SecretKey2    string            `json:"secret-key2,omitempty"`
	Token         string            `json:"token,omitempty"`
	Passphrase    string            `json:"passphrase,omitempty"`
	Envs          map[string]string `json:"envs_map,omitempty"`
	EncryptRsaKey string            `json:"encrypt_rsa_key,omitempty"`
	InitConfig    string            `json:"initconfig,omitempty"`
	Configs       map[string]string `json:"configs_map,omitempty"`

	// put in volCtx
	DeletedDelay string   `json:"deleted_delay"`
	CleanCache   bool     `json:"clean_cache"`
	HostPath     []string `json:"host_path"`

	FormatCmd string // format or auth

	PV  *corev1.PersistentVolume      `json:"-"`
	PVC *corev1.PersistentVolumeClaim `json:"-"`
}

type AppInfo struct {
	Name      string
	Namespace string
}

type PodAttr struct {
	Namespace            string
	MountPointPath       string
	JFSConfigPath        string
	JFSMountPriorityName string
	ServiceAccountName   string

	Resources corev1.ResourceRequirements

	Labels                        map[string]string     `json:"labels,omitempty"`
	Annotations                   map[string]string     `json:"annotations,omitempty"`
	LivenessProbe                 *corev1.Probe         `json:"livenessProbe,omitempty"`
	ReadinessProbe                *corev1.Probe         `json:"readinessProbe,omitempty"`
	StartupProbe                  *corev1.Probe         `json:"startupProbe,omitempty"`
	Lifecycle                     *corev1.Lifecycle     `json:"lifecycle,omitempty"`
	TerminationGracePeriodSeconds *int64                `json:"terminationGracePeriodSeconds,omitempty"`
	Volumes                       []corev1.Volume       `json:"volumes,omitempty"`
	VolumeDevices                 []corev1.VolumeDevice `json:"volumeDevices,omitempty"`
	VolumeMounts                  []corev1.VolumeMount  `json:"volumeMounts,omitempty"`
	Env                           []corev1.EnvVar       `json:"env,omitempty"`

	// inherit from csi
	Image            string
	HostNetwork      bool
	HostAliases      []corev1.HostAlias
	HostPID          bool
	HostIPC          bool
	DNSConfig        *corev1.PodDNSConfig
	DNSPolicy        corev1.DNSPolicy
	ImagePullSecrets []corev1.LocalObjectReference
	PreemptionPolicy *corev1.PreemptionPolicy
	Tolerations      []corev1.Toleration
}

type PVCSelector struct {
	metav1.LabelSelector
	MatchStorageClassName string `json:"matchStorageClassName,omitempty"`
	MatchName             string `json:"matchName,omitempty"`
}

type MountPodPatch struct {
	// used to specify the selector for the PVC that will be patched
	// omit will patch for all PVC
	PVCSelector *PVCSelector `json:"pvcSelector,omitempty"`

	MountImage string `json:"mountImage,omitempty"`

	Image                         string                       `json:"-"`
	Labels                        map[string]string            `json:"labels,omitempty"`
	Annotations                   map[string]string            `json:"annotations,omitempty"`
	HostNetwork                   *bool                        `json:"hostNetwork,omitempty" `
	HostPID                       *bool                        `json:"hostPID,omitempty" `
	LivenessProbe                 *corev1.Probe                `json:"livenessProbe,omitempty"`
	ReadinessProbe                *corev1.Probe                `json:"readinessProbe,omitempty"`
	StartupProbe                  *corev1.Probe                `json:"startupProbe,omitempty"`
	Lifecycle                     *corev1.Lifecycle            `json:"lifecycle,omitempty"`
	Resources                     *corev1.ResourceRequirements `json:"resources,omitempty"`
	TerminationGracePeriodSeconds *int64                       `json:"terminationGracePeriodSeconds,omitempty"`
	Volumes                       []corev1.Volume              `json:"volumes,omitempty"`
	VolumeDevices                 []corev1.VolumeDevice        `json:"volumeDevices,omitempty"`
	VolumeMounts                  []corev1.VolumeMount         `json:"volumeMounts,omitempty"`
	Env                           []corev1.EnvVar              `json:"env,omitempty"`
	MountOptions                  []string                     `json:"mountOptions,omitempty"`
}

type CachePVC struct {
	PVCName string
	Path    string
}

type CacheInlineVolume struct {
	CSI  *corev1.CSIVolumeSource
	Path string
}

type CacheEmptyDir struct {
	Medium    string
	SizeLimit resource.Quantity
	Path      string
}

func (mpp *MountPodPatch) IsMatch(pvc *corev1.PersistentVolumeClaim) bool {
	if mpp.PVCSelector == nil {
		return true
	}
	if pvc == nil {
		return false
	}
	if mpp.PVCSelector.MatchName != "" && mpp.PVCSelector.MatchName != pvc.Name {
		return false
	}
	if mpp.PVCSelector.MatchStorageClassName != "" && pvc.Spec.StorageClassName != nil && mpp.PVCSelector.MatchStorageClassName != *pvc.Spec.StorageClassName {
		return false
	}
	selector, err := metav1.LabelSelectorAsSelector(&mpp.PVCSelector.LabelSelector)
	if err != nil {
		return false
	}
	return selector.Matches(labels.Set(pvc.Labels))
}

func (mpp *MountPodPatch) DeepCopy() MountPodPatch {
	var copy MountPodPatch
	data, _ := json.Marshal(mpp)
	_ = json.Unmarshal(data, &copy)
	return copy
}

func (mpp *MountPodPatch) Merge(mp MountPodPatch) {
	mpp.MountImage = mp.MountImage
	if mp.HostNetwork != nil {
		mpp.HostNetwork = mp.HostNetwork
	}
	if mp.HostPID != nil {
		mpp.HostPID = mp.HostPID
	}
	if mp.LivenessProbe != nil {
		mpp.LivenessProbe = mp.LivenessProbe
	}
	if mp.ReadinessProbe != nil {
		mpp.ReadinessProbe = mp.ReadinessProbe
	}
	if mp.ReadinessProbe != nil {
		mpp.ReadinessProbe = mp.ReadinessProbe
	}
	if mp.Lifecycle != nil {
		mpp.Lifecycle = mp.Lifecycle
	}
	if mp.Labels != nil {
		mpp.Labels = mp.Labels
	}
	if mp.Annotations != nil {
		mpp.Annotations = mp.Annotations
	}
	if mp.Resources != nil {
		mpp.Resources = mp.Resources
	}
	if mp.TerminationGracePeriodSeconds != nil {
		mpp.TerminationGracePeriodSeconds = mp.TerminationGracePeriodSeconds
	}
	vok := make(map[string]bool)
	if mp.Volumes != nil {
		if mpp.Volumes == nil {
			mpp.Volumes = []corev1.Volume{}
		}
		for _, v := range mp.Volumes {
			if IsInterVolume(v.Name) {
				klog.Info("applyConfig: volume uses an internal volume name, ignore", "volume", v.Name)
				continue
			}
			found := false
			for _, vv := range mpp.Volumes {
				if vv.Name == v.Name {
					found = true
					break
				}
			}
			if found {
				klog.Info("applyConfig: volume already exists, ignore", "volume", v.Name)
				continue
			}
			vok[v.Name] = true
			mpp.Volumes = append(mpp.Volumes, v)
		}
	}
	if mp.VolumeMounts != nil {
		if mpp.VolumeMounts == nil {
			mpp.VolumeMounts = []corev1.VolumeMount{}
		}
		for _, vm := range mp.VolumeMounts {
			if !vok[vm.Name] {
				klog.Info("applyConfig: volumeMount not exists in volumes, ignore", "volume", vm.Name)
				continue
			}
			mpp.VolumeMounts = append(mpp.VolumeMounts, vm)
		}
	}
	if mp.VolumeDevices != nil {
		if mpp.VolumeDevices == nil {
			mpp.VolumeDevices = []corev1.VolumeDevice{}
		}
		for _, vm := range mp.VolumeDevices {
			if !vok[vm.Name] {
				klog.Info("applyConfig: volumeDevices not exists in volumes, ignore", "volume", vm.Name)
				continue
			}
			mpp.VolumeDevices = append(mpp.VolumeDevices, vm)
		}
	}
	if mp.Env != nil {
		mpp.Env = mp.Env
	}
	if mp.MountOptions != nil {
		mpp.MountOptions = mp.MountOptions
	}
}

var interVolumesPrefix = []string{
	"rsa-key",
	"init-config",
	"config-",
	"jfs-dir",
	"update-db",
	"cachedir-",
}

func IsInterVolume(name string) bool {
	for _, prefix := range interVolumesPrefix {
		if strings.HasPrefix(name, prefix) {
			return true
		}
	}
	return false
}

func ParseAppInfo(volCtx map[string]string) (*AppInfo, error) {
	// check kubelet access. If not, should turn `podInfoOnMount` on in csiDriver, and fallback to apiServer
	if KubeletPort != "" && HostIp != "" {
		port, err := strconv.Atoi(KubeletPort)
		if err != nil {
			return nil, err
		}
		kc, err := k8sclient.NewKubeletClient(HostIp, port)
		if err != nil {
			return nil, err
		}
		if _, err := kc.GetNodeRunningPods(); err != nil {
			if volCtx == nil || volCtx[PodInfoName] == "" {
				return nil, fmt.Errorf("can not connect to kubelet, please turn `podInfoOnMount` on in csiDriver, and fallback to apiServer")
			}
		}
	}
	if volCtx != nil {
		return &AppInfo{
			Name:      volCtx[PodInfoName],
			Namespace: volCtx[PodInfoNamespace],
		}, nil
	}
	return nil, nil
}
